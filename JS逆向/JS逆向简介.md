 

#### 文章目录

*   [前言](#_6)
*   [一、接口抓包](#_12)
*   [二、逆向分析](#_27)
*   [3\. 接口验证](#3__49)
*   [总结](#_53)

* * *

前言
--

出于对数据安全的考虑，现代化的网站/APP通常会对数据接口做加密处理。而分析这些接口的加密算法并实现模拟调用的过程就叫做「逆向」。逆向对于爬虫工程师来说是一个永远绕不开的话题，也逐渐成为各企业招聘时，JD 中的一个必备技能要求。

本文就以某在线翻译网站接口加密参数分析为案例，分享一下网页爬虫的逆向原理、分析思路和分析过程。

一、接口抓包
------

首先，我们访问这个网站，在左侧文本框中输入要翻译的文字：  
![在这里插入图片描述](https://img-blog.csdnimg.cn/74939a75ab9e4175801aa030511b6369.png)

可以看到，输入一个“你好”后，不到一秒钟的时间，右侧文本框中就显示对应的英文翻译结果。我们思考一下实现原理，首先这个事情不可能是纯粹放在客户端实现（这意味着网页临时文件中要存放一个庞大的词典库，显然不现实），那么它一定是由客户端向服务端发起了一个网络请求，服务端处理完成后再将结果返回给客户端，最后渲染到页面上。

既然过程中存在网络请求，就可以通过抓包工具抓取对应请求接口，看看具体的接口地址、请求参数以及返回结果。这几样东西明确了，不就意味着可以通过调取这个翻译接口来自己实现一个翻译功能吗？所以网站并不会那么轻易地就让任何人把这个接口调通。  
![在这里插入图片描述](https://img-blog.csdnimg.cn/66691f5d261a4e47b24088d27e20a0b4.png)

打开浏览器开发者工具，切换到「Network」选项卡，确实捕获到了一个接口请求：  
可以看到，这是一个 POST 请求，请求头中包含17个参数（无关紧要，这里不做展开），请求参数体中的 i 就是我们刚刚在页面上输入的文本内容“你好”。仔细分析一下请求体中的每个参数，大部分参数都可以直接写死，或者是时间戳，但其中的 sign 参数是我们比较疑惑的。如果模拟调用一下这个接口，就会发现，sign 是这个接口的必传参数，且必须要传正确的值。显然，这个 sign 就是该网站用来防止第三方程序调用的加密措施。

二、逆向分析
------

通过上面的接口抓包，我们已经有了一个明确的目标，就是分析出 sign 参数的加密算法，然后自己实现这个算法进行参数生成和接口调用。有了目标之后，我们先思考一下，这个参数到底是什么时候以及在哪里被生成的呢？刚刚我们看到，这是接口请求体中的一个参数，所以它一定是在请求发起前在客户端生成的，而网页前端使用的交互逻辑代码是 Javascript，也就是说，它的加密算法很可能就在网页资源文件中的 JS 代码里，关键是能不能把它找出来。

我们先来试试关键词检索的方式。打开浏览器开发者工具，切换到「Sources」选项卡，在底部搜索框中输入“sign”，会有一个 JS 文件的搜索结果。进入这个文件里边再搜索下，会匹配到 15 条结果，浏览一遍这 15 条结果，就会发现下面这行“疑似加密算法”的代码，因为它用到了 MD5 方法，这是一种被广泛使用的加密算法。  
![在这里插入图片描述](https://img-blog.csdnimg.cn/3b2aa4bd724145c79bbdee71b5a999f8.png)  
接下来，我们就得验证一下，它到底是不是我们的目标加密算法，验证的方式就是看看这行代码计算的结果，与接口发起请求时传的「sign」参数值是否一致。想看这行代码的执行结果，可以给它打上断点，然后再去页面上输入一次文本进行翻译。如果发起请求前执行到了这行代码，程序就会暂停在这行代码的位置，这时候就能看到执行结果了。  
![在这里插入图片描述](https://img-blog.csdnimg.cn/f45204feb0e34131b156285e663d3160.png)  
底部 「Console」是控制台，这里可以执行在当前环境下的 JS 代码，我们直接输入那行“疑似加密算法”的代码在这里执行，得到的值为 “b9f9df08d53c54eeef463dee79459ea1” 我们先将这个结果记录下来。

由于加密算法里还用到了 e 和 i 参数，我们也顺便打印了一下这两个值，他们分别是「你好」和「16197727689967」（看起来像时间戳的一长串数字，待会再讲）。

现在我们让程序继续执行，再切回「Network」选项卡，看看接口传参的 sign 是什么值：  
![在这里插入图片描述](https://img-blog.csdnimg.cn/e43285172ef744bc9c76306a7611a525.png)  
可以看到，接口参数中的 sign 值和我们刚刚记录的结果是一致的，且其中的 salt 参数，也跟刚刚打印的 i 的值一致。

由于 salt 也是接口中的必要参数，且现在看来它还得作为 sign 的加密参数之一，那就也得弄清楚 salt 的生成方式。从表面看，它很像是时间戳，但时间戳通常要么是10位（精确到秒），要么是13位（精确到毫秒），但它却有 14 位。所以它可能是基于时间戳还做了什么修改，我们回到刚刚加密算法的代码位置，定位到 i 参数，往上追溯，会发现 i 的生成方法，就在代码的第 8380 行和 8381 行上。  
![在这里插入图片描述](https://img-blog.csdnimg.cn/50602c33f4c54dcb906d3f1307f92ba2.png)  
很明显，它是用当前时间戳（13位），和一个 0-9 的随机数，拼接而成。

至此，我们就能得到 sign 的加密算法为： md5(“fanyideskweb” + e + i + “Tbh5E8=q6U3EXe+&L\[4c@”) , 其中首尾两个是写死的字符串，e 为要翻译的文本内容，i 为时间戳+一位 0 到 9 的随机数。

3\. 接口验证
--------

清楚加密算法和逻辑后，剩下的事情就简单了。写一个 Python 程序模拟调用一下接口即可。  
![在这里插入图片描述](https://img-blog.csdnimg.cn/497dac465fa34a56a96f1f9e0c2f50b2.png)  
可以看到，接口成功调通返回正确结果，不仅能翻译单词，还能翻译句子，甚至还能自动检测语言翻译为中文，相当于网站中在线翻译支持的功能，这里都能支持了。

总结
--

本文通过一个案例分享了爬虫逆向的原理和思路，由于案例比较简单，仅通过在网页 JS 资源文件里直接搜索关键词就能找到对应的加密算法。而大部分时候其实不会这么顺利，因为网站既然已经对参数做了加密，就会想办法把加密算法也“藏起来”，比如加入大量「程序执行时确实有调用，却无任何实际意义的代码」、「将变量名和方法名作混淆后降低可读性」等，以此来增加爬虫工程师调试分析的难度和时间成本。
